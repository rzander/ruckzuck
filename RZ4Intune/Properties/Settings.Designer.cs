//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace RuckZuck_Tool.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.8.1.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool UpgradeSettings {
            get {
                return ((bool)(this["UpgradeSettings"]));
            }
            set {
                this["UpgradeSettings"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool DisableBroadcast {
            get {
                return ((bool)(this["DisableBroadcast"]));
            }
            set {
                this["DisableBroadcast"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("")]
        public string CustomerID {
            get {
                return ((string)(this["CustomerID"]));
            }
            set {
                this["CustomerID"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool ShowAbout {
            get {
                return ((bool)(this["ShowAbout"]));
            }
            set {
                this["ShowAbout"] = value;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("https://graph.microsoft.com/beta/deviceAppManagement/mobileApps?$select=id,Displa" +
            "yName,notes&$filter=startswith(notes,\'RZID:\')")]
        public string RZGetExistingAppsURL {
            get {
                return ((string)(this["RZGetExistingAppsURL"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("DeviceManagementConfiguration.ReadWrite.All;DeviceManagementApps.ReadWrite.All")]
        public string RZSecurityScope {
            get {
                return ((string)(this["RZSecurityScope"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("<#\r\n\r\n.COPYRIGHT\r\nCopyright (c) Microsoft Corporation. All rights reserved. Licen" +
            "sed under the MIT license.\r\nSee LICENSE in the project root for license informat" +
            "ion.\r\nhttps://github.com/microsoftgraph/powershell-intune-samples/tree/master/LO" +
            "B_Application\r\n#>\r\n\r\n####################################################\r\n\r\nfun" +
            "ction Get-AuthToken {\r\n\r\n    <#\r\n.SYNOPSIS\r\nThis function is used to authenticat" +
            "e with the Graph API REST interface\r\n.DESCRIPTION\r\nThe function authenticate wit" +
            "h the Graph API Interface with the tenant name\r\n.EXAMPLE\r\nGet-AuthToken\r\nAuthent" +
            "icates you with the Graph API interface\r\n.NOTES\r\nNAME: Get-AuthToken\r\n#>\r\n\r\n    " +
            "[cmdletbinding()]\r\n\r\n    param\r\n    (\r\n        [Parameter(Mandatory = $true)]\r\n " +
            "       $User\r\n    )\r\n\r\n    $userUpn = New-Object \"System.Net.Mail.MailAddress\" -" +
            "ArgumentList $User\r\n\r\n    $tenant = $userUpn.Host\r\n\r\n    Write-Host \"Checking fo" +
            "r AzureAD module...\"\r\n\r\n    $AadModule = Get-Module -Name \"AzureAD\" -ListAvailab" +
            "le\r\n\r\n    if ($AadModule -eq $null) {\r\n\r\n        Write-Host \"AzureAD PowerShell " +
            "module not found, looking for AzureADPreview\"\r\n        $AadModule = Get-Module -" +
            "Name \"AzureADPreview\" -ListAvailable\r\n\r\n    }\r\n\r\n    if ($AadModule -eq $null) {" +
            "\r\n        write-host\r\n        write-host \"AzureAD Powershell module not installe" +
            "d...\" -f Red\r\n        write-host \"Install by running \'Install-Module AzureAD\' or" +
            " \'Install-Module AzureADPreview\' from an elevated PowerShell prompt\" -f Yellow\r\n" +
            "        write-host \"Script can\'t continue...\" -f Red\r\n        write-host\r\n      " +
            "  exit\r\n    }\r\n\r\n    # Getting path to ActiveDirectory Assemblies\r\n    # If the " +
            "module count is greater than 1 find the latest version\r\n\r\n    if ($AadModule.cou" +
            "nt -gt 1) {\r\n\r\n        $Latest_Version = ($AadModule | select version | Sort-Obj" +
            "ect)[-1]\r\n\r\n        $aadModule = $AadModule | ? { $_.version -eq $Latest_Version" +
            ".version }\r\n\r\n        # Checking if there are multiple versions of the same modu" +
            "le found\r\n\r\n        if ($AadModule.count -gt 1) {\r\n\r\n            $aadModule = $A" +
            "adModule | select -Unique\r\n\r\n        }\r\n\r\n        $adal = Join-Path $AadModule.M" +
            "oduleBase \"Microsoft.IdentityModel.Clients.ActiveDirectory.dll\"\r\n        $adalfo" +
            "rms = Join-Path $AadModule.ModuleBase \"Microsoft.IdentityModel.Clients.ActiveDir" +
            "ectory.Platform.dll\"\r\n\r\n    }\r\n\r\n    else {\r\n\r\n        $adal = Join-Path $AadMod" +
            "ule.ModuleBase \"Microsoft.IdentityModel.Clients.ActiveDirectory.dll\"\r\n        $a" +
            "dalforms = Join-Path $AadModule.ModuleBase \"Microsoft.IdentityModel.Clients.Acti" +
            "veDirectory.Platform.dll\"\r\n\r\n    }\r\n\r\n    [System.Reflection.Assembly]::LoadFrom" +
            "($adal) | Out-Null\r\n\r\n    [System.Reflection.Assembly]::LoadFrom($adalforms) | O" +
            "ut-Null\r\n\r\n    $clientId = \"d1ddf0e4-d672-4dae-b554-9d5bdfd93547\"\r\n\r\n    $redire" +
            "ctUri = \"urn:ietf:wg:oauth:2.0:oob\"\r\n\r\n    $resourceAppIdURI = \"https://graph.mi" +
            "crosoft.com\"\r\n\r\n    $authority = \"https://login.microsoftonline.com/$Tenant\"\r\n\r\n" +
            "    try {\r\n\r\n        $authContext = New-Object \"Microsoft.IdentityModel.Clients." +
            "ActiveDirectory.AuthenticationContext\" -ArgumentList $authority\r\n\r\n        # htt" +
            "ps://msdn.microsoft.com/en-us/library/azure/microsoft.identitymodel.clients.acti" +
            "vedirectory.promptbehavior.aspx\r\n        # Change the prompt behaviour to force " +
            "credentials each time: Auto, Always, Never, RefreshSession\r\n\r\n        $platformP" +
            "arameters = New-Object \"Microsoft.IdentityModel.Clients.ActiveDirectory.Platform" +
            "Parameters\" -ArgumentList \"Auto\"\r\n\r\n        $userId = New-Object \"Microsoft.Iden" +
            "tityModel.Clients.ActiveDirectory.UserIdentifier\" -ArgumentList ($User, \"Optiona" +
            "lDisplayableId\")\r\n\r\n        $authResult = $authContext.AcquireTokenAsync($resour" +
            "ceAppIdURI, $clientId, $redirectUri, $platformParameters, $userId).Result\r\n\r\n   " +
            "     # If the accesstoken is valid then create the authentication header\r\n\r\n    " +
            "    if ($authResult.AccessToken) {\r\n\r\n            # Creating header for Authoriz" +
            "ation token\r\n\r\n            $authHeader = @{\r\n                \'Content-Type\'  = \'" +
            "application/json\'\r\n                \'Authorization\' = \"Bearer \" + $authResult.Acc" +
            "essToken\r\n                \'ExpiresOn\'     = $authResult.ExpiresOn\r\n            }" +
            "\r\n\r\n            return $authHeader\r\n\r\n        }\r\n\r\n        else {\r\n\r\n           " +
            " Write-Host\r\n            Write-Host \"Authorization Access Token is null, please " +
            "re-run authentication...\" -ForegroundColor Red\r\n            Write-Host\r\n        " +
            "    break\r\n\r\n        }\r\n\r\n    }\r\n\r\n    catch {\r\n\r\n        write-host $_.Exceptio" +
            "n.Message -f Red\r\n        write-host $_.Exception.ItemName -f Red\r\n        write" +
            "-host\r\n        break\r\n\r\n    }\r\n\r\n}\r\n \r\n#########################################" +
            "###########\r\n\r\nfunction CloneObject($object) {\r\n\r\n    $stream = New-Object IO.Me" +
            "moryStream;\r\n    $formatter = New-Object Runtime.Serialization.Formatters.Binary" +
            ".BinaryFormatter;\r\n    $formatter.Serialize($stream, $object);\r\n    $stream.Posi" +
            "tion = 0;\r\n    $formatter.Deserialize($stream);\r\n}\r\n\r\n##########################" +
            "##########################\r\n\r\nfunction WriteHeaders($authToken) {\r\n\r\n    foreach" +
            " ($header in $authToken.GetEnumerator()) {\r\n        if ($header.Name.ToLower() -" +
            "eq \"authorization\") {\r\n            continue;\r\n        }\r\n\r\n        Write-Host -F" +
            "oregroundColor Gray \"$($header.Name): $($header.Value)\";\r\n    }\r\n}\r\n\r\n##########" +
            "##########################################\r\n\r\nfunction MakeGetRequest($collectio" +
            "nPath) {\r\n\r\n    $uri = \"$baseUrl$collectionPath\";\r\n    $request = \"GET $uri\";\r\n\t" +
            "\r\n    if ($logRequestUris) { Write-Host $request; }\r\n    if ($logHeaders) { Writ" +
            "eHeaders $authToken; }\r\n\r\n    try {\r\n        Test-AuthToken\r\n        $response =" +
            " Invoke-RestMethod $uri -Method Get -Headers $authToken;\r\n        $response;\r\n  " +
            "  }\r\n    catch {\r\n        Write-Host -ForegroundColor Red $request;\r\n        Wri" +
            "te-Host -ForegroundColor Red $_.Exception.Message;\r\n        throw;\r\n    }\r\n}\r\n\r\n" +
            "####################################################\r\n\r\nfunction MakePatchReques" +
            "t($collectionPath, $body) {\r\n\r\n    MakeRequest \"PATCH\" $collectionPath $body;\r\n\r" +
            "\n}\r\n\r\n####################################################\r\n\r\nfunction MakePostR" +
            "equest($collectionPath, $body) {\r\n\r\n    MakeRequest \"POST\" $collectionPath $body" +
            ";\r\n\r\n}\r\n\r\n####################################################\r\n\r\nfunction MakeR" +
            "equest($verb, $collectionPath, $body) {\r\n\r\n    $uri = \"$baseUrl$collectionPath\";" +
            "\r\n    $request = \"$verb $uri\";\r\n\t\r\n    $clonedHeaders = CloneObject $authToken;\r" +
            "\n    $clonedHeaders[\"content-length\"] = $body.Length;\r\n    $clonedHeaders[\"conte" +
            "nt-type\"] = \"application/json\";\r\n\r\n    if ($logRequestUris) { Write-Host $reques" +
            "t; }\r\n    if ($logHeaders) { WriteHeaders $clonedHeaders; }\r\n    if ($logContent" +
            ") { Write-Host -ForegroundColor Gray $body; }\r\n\r\n    try {\r\n        Test-AuthTok" +
            "en\r\n        $response = Invoke-RestMethod $uri -Method $verb -Headers $clonedHea" +
            "ders -Body $body;\r\n        $response;\r\n    }\r\n    catch {\r\n        Write-Host -F" +
            "oregroundColor Red $request;\r\n        Write-Host -ForegroundColor Red $_.Excepti" +
            "on.Message;\r\n        throw;\r\n    }\r\n}\r\n\r\n#######################################" +
            "#############\r\n\r\nfunction UploadAzureStorageChunk($sasUri, $id, $body) {\r\n\r\n    " +
            "$uri = \"$sasUri&comp=block&blockid=$id\";\r\n    $request = \"PUT $uri\";\r\n\r\n    $iso" +
            " = [System.Text.Encoding]::GetEncoding(\"iso-8859-1\");\r\n    $encodedBody = $iso.G" +
            "etString($body);\r\n    $headers = @{\r\n        \"x-ms-blob-type\" = \"BlockBlob\"\r\n   " +
            " };\r\n\r\n    if ($logRequestUris) { Write-Host $request; }\r\n    if ($logHeaders) {" +
            " WriteHeaders $headers; }\r\n\r\n    try {\r\n        $response = Invoke-WebRequest $u" +
            "ri -Method Put -Headers $headers -Body $encodedBody;\r\n    }\r\n    catch {\r\n      " +
            "  Write-Host -ForegroundColor Red $request;\r\n        Write-Host -ForegroundColor" +
            " Red $_.Exception.Message;\r\n        throw;\r\n    }\r\n\r\n}\r\n\r\n######################" +
            "##############################\r\n\r\nfunction FinalizeAzureStorageUpload($sasUri, $" +
            "ids) {\r\n\r\n    $uri = \"$sasUri&comp=blocklist\";\r\n    $request = \"PUT $uri\";\r\n\r\n  " +
            "  $xml = \'<?xml version=\"1.0\" encoding=\"utf-8\"?><BlockList>\';\r\n    foreach ($id " +
            "in $ids) {\r\n        $xml += \"<Latest>$id</Latest>\";\r\n    }\r\n    $xml += \'</Block" +
            "List>\';\r\n\r\n    if ($logRequestUris) { Write-Host $request; }\r\n    if ($logConten" +
            "t) { Write-Host -ForegroundColor Gray $xml; }\r\n\r\n    try {\r\n        Invoke-RestM" +
            "ethod $uri -Method Put -Body $xml;\r\n    }\r\n    catch {\r\n        Write-Host -Fore" +
            "groundColor Red $request;\r\n        Write-Host -ForegroundColor Red $_.Exception." +
            "Message;\r\n        throw;\r\n    }\r\n}\r\n\r\n##########################################" +
            "##########\r\n\r\nfunction UploadFileToAzureStorage($sasUri, $filepath, $fileUri) {\r" +
            "\n\r\n    try {\r\n\r\n        $chunkSizeInBytes = 1024l * 1024l * $azureStorageUploadC" +
            "hunkSizeInMb;\r\n\t\t\r\n        # Start the timer for SAS URI renewal.\r\n        $sasR" +
            "enewalTimer = [System.Diagnostics.Stopwatch]::StartNew()\r\n\t\t\r\n        # Find the" +
            " file size and open the file.\r\n        $fileSize = (Get-Item $filepath).length;\r" +
            "\n        $chunks = [Math]::Ceiling($fileSize / $chunkSizeInBytes);\r\n        $rea" +
            "der = New-Object System.IO.BinaryReader([System.IO.File]::Open($filepath, [Syste" +
            "m.IO.FileMode]::Open));\r\n        $position = $reader.BaseStream.Seek(0, [System." +
            "IO.SeekOrigin]::Begin);\r\n\t\t\r\n        # Upload each chunk. Check whether a SAS UR" +
            "I renewal is required after each chunk is uploaded and renew if needed.\r\n       " +
            " $ids = @();\r\n\r\n        for ($chunk = 0; $chunk -lt $chunks; $chunk++) {\r\n\r\n    " +
            "        $id = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.Get" +
            "Bytes($chunk.ToString(\"0000\")));\r\n            $ids += $id;\r\n\r\n            $start" +
            " = $chunk * $chunkSizeInBytes;\r\n            $length = [Math]::Min($chunkSizeInBy" +
            "tes, $fileSize - $start);\r\n            $bytes = $reader.ReadBytes($length);\r\n\t\t\t" +
            "\r\n            $currentChunk = $chunk + 1;\t\t\t\r\n\r\n            Write-Progress -Acti" +
            "vity \"Uploading File to Azure Storage\" -status \"Uploading chunk $currentChunk of" +
            " $chunks\" `\r\n                -percentComplete ($currentChunk / $chunks * 100)\r\n\r" +
            "\n            $uploadResponse = UploadAzureStorageChunk $sasUri $id $bytes;\r\n\t\t\t\r" +
            "\n            # Renew the SAS URI if 7 minutes have elapsed since the upload star" +
            "ted or was renewed last.\r\n            if ($currentChunk -lt $chunks -and $sasRen" +
            "ewalTimer.ElapsedMilliseconds -ge 450000) {\r\n\r\n                $renewalResponse " +
            "= RenewAzureStorageUpload $fileUri;\r\n                $sasRenewalTimer.Restart();" +
            "\r\n\t\t\t\r\n            }\r\n\r\n        }\r\n\r\n        Write-Progress -Completed -Activity" +
            " \"Uploading File to Azure Storage\"\r\n\r\n        $reader.Close();\r\n\r\n    }\r\n\r\n    f" +
            "inally {\r\n\r\n        if ($reader -ne $null) { $reader.Dispose(); }\r\n\t\r\n    }\r\n\t\r\n" +
            "    # Finalize the upload.\r\n    $uploadResponse = FinalizeAzureStorageUpload $sa" +
            "sUri $ids;\r\n\r\n}\r\n\r\n####################################################\r\n\r\nfunct" +
            "ion RenewAzureStorageUpload($fileUri) {\r\n\r\n    $renewalUri = \"$fileUri/renewUplo" +
            "ad\";\r\n    $actionBody = \"\";\r\n    $rewnewUriResult = MakePostRequest $renewalUri " +
            "$actionBody;\r\n\t\r\n    $file = WaitForFileProcessing $fileUri \"AzureStorageUriRene" +
            "wal\" $azureStorageRenewSasUriBackOffTimeInSeconds;\r\n\r\n}\r\n\r\n#####################" +
            "###############################\r\n\r\nfunction WaitForFileProcessing($fileUri, $sta" +
            "ge) {\r\n\r\n    $attempts = 600;\r\n    $waitTimeInSeconds = 10;\r\n\r\n    $successState" +
            " = \"$($stage)Success\";\r\n    $pendingState = \"$($stage)Pending\";\r\n    $failedStat" +
            "e = \"$($stage)Failed\";\r\n    $timedOutState = \"$($stage)TimedOut\";\r\n\r\n    $file =" +
            " $null;\r\n    while ($attempts -gt 0) {\r\n        $file = MakeGetRequest $fileUri;" +
            "\r\n\r\n        if ($file.uploadState -eq $successState) {\r\n            break;\r\n    " +
            "    }\r\n        elseif ($file.uploadState -ne $pendingState) {\r\n            Write" +
            "-Host -ForegroundColor Red $_.Exception.Message;\r\n            throw \"File upload" +
            " state is not success: $($file.uploadState)\";\r\n        }\r\n\r\n        Start-Sleep " +
            "$waitTimeInSeconds;\r\n        $attempts--;\r\n    }\r\n\r\n    if ($file -eq $null -or " +
            "$file.uploadState -ne $successState) {\r\n        throw \"File request did not comp" +
            "lete in the allotted time.\";\r\n    }\r\n\r\n    $file;\r\n}\r\n\r\n########################" +
            "############################\r\n\r\nfunction GetWin32AppBody() {\r\n\r\n    param\r\n    (" +
            "\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"MSI\", Position = 1" +
            ")]\r\n        [Switch]$MSI,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetN" +
            "ame = \"EXE\", Position = 1)]\r\n        [Switch]$EXE,\r\n\r\n        [parameter(Mandato" +
            "ry = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$displayName,\r" +
            "\n\r\n        [parameter(Mandatory = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n " +
            "       [string]$publisher,\r\n\r\n        [parameter(Mandatory = $true)]\r\n        [V" +
            "alidateNotNullOrEmpty()]\r\n        [string]$description,\r\n\r\n        [parameter(Ma" +
            "ndatory = $false)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$display" +
            "Version = \"\",\r\n\r\n        [parameter(Mandatory = $true)]\r\n        [ValidateNotNul" +
            "lOrEmpty()]\r\n        [string]$filename,\r\n\r\n        [parameter(Mandatory = $true)" +
            "]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$SetupFileName,\r\n\r\n      " +
            "  [parameter(Mandatory = $true)]\r\n        [ValidateSet(\'system\', \'user\')]\r\n     " +
            "   $installExperience = \"system\",\r\n\r\n        [parameter(Mandatory = $false)]\r\n  " +
            "      [ValidateNotNullOrEmpty()]\r\n        [string]$imageValue,\r\n\r\n        [param" +
            "eter(Mandatory = $false)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $informat" +
            "ionURL,\r\n\r\n        [parameter(Mandatory = $false)]\r\n        [ValidateNotNullOrEm" +
            "pty()]\r\n        $developer,\r\n\r\n        [parameter(Mandatory = $true, ParameterSe" +
            "tName = \"EXE\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $installCommandLine" +
            ",\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"EXE\")]\r\n        [" +
            "ValidateNotNullOrEmpty()]\r\n        $uninstallCommandLine,\r\n\r\n        [parameter(" +
            "Mandatory = $true, ParameterSetName = \"MSI\")]\r\n        [ValidateNotNullOrEmpty()" +
            "]\r\n        $MsiPackageType,\r\n\r\n        [parameter(Mandatory = $true, ParameterSe" +
            "tName = \"MSI\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $MsiProductCode,\r\n\r" +
            "\n        [parameter(Mandatory = $false, ParameterSetName = \"MSI\")]\r\n        $Msi" +
            "ProductName,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"MSI\")]" +
            "\r\n        [ValidateNotNullOrEmpty()]\r\n        $MsiProductVersion,\r\n\r\n        [pa" +
            "rameter(Mandatory = $false, ParameterSetName = \"MSI\")]\r\n        $MsiPublisher,\r\n" +
            "\r\n        [parameter(Mandatory = $true, ParameterSetName = \"MSI\")]\r\n        [Val" +
            "idateNotNullOrEmpty()]\r\n        $MsiRequiresReboot,\r\n\r\n        [parameter(Mandat" +
            "ory = $true, ParameterSetName = \"MSI\")]\r\n        [ValidateNotNullOrEmpty()]\r\n   " +
            "     $MsiUpgradeCode\r\n\r\n    )\r\n\r\n    if ($MSI) {\r\n\r\n        $body = @{ \"@odata.t" +
            "ype\" = \"#microsoft.graph.win32LobApp\" };\r\n        $body.applicableArchitectures " +
            "= \"x64,x86\";\r\n        $body.description = $description;\r\n        $body.developer" +
            " = \"\";\r\n        $body.displayName = $displayName;\r\n        $body.fileName = $fil" +
            "ename;\r\n        $body.installCommandLine = \"msiexec /i `\"$SetupFileName`\"\"\r\n    " +
            "    $body.installExperience = @{\"runAsAccount\" = \"$installExperience\" };\r\n      " +
            "  $body.informationUrl = $null;\r\n        $body.isFeatured = $false;\r\n        $bo" +
            "dy.minimumSupportedOperatingSystem = @{\"v10_1607\" = $true };\r\n        $body.msiI" +
            "nformation = @{\r\n            \"packageType\"    = \"$MsiPackageType\";\r\n            " +
            "\"productCode\"    = \"$MsiProductCode\";\r\n            \"productName\"    = \"$MsiProdu" +
            "ctName\";\r\n            \"productVersion\" = \"$MsiProductVersion\";\r\n            \"pub" +
            "lisher\"      = \"$MsiPublisher\";\r\n            \"requiresReboot\" = \"$MsiRequiresReb" +
            "oot\";\r\n            \"upgradeCode\"    = \"$MsiUpgradeCode\"\r\n        };\r\n        $bo" +
            "dy.notes = \"\";\r\n        $body.owner = \"\";\r\n        $body.privacyInformationUrl =" +
            " $null;\r\n        $body.publisher = $publisher;\r\n        $body.runAs32bit = $fals" +
            "e;\r\n        $body.setupFilePath = $SetupFileName;\r\n        $body.uninstallComman" +
            "dLine = \"msiexec /x `\"$MsiProductCode`\"\"\r\n        $body.displayVersion = \"$($dis" +
            "playVersion)\"\r\n\r\n    }\r\n\r\n    elseif ($EXE) {\r\n\r\n        $body = @{ \"@odata.type" +
            "\" = \"#microsoft.graph.win32LobApp\" };\r\n        $body.description = $description;" +
            "\r\n        $body.developer = $developer;\r\n        $body.displayName = $displayNam" +
            "e;\r\n        $body.fileName = $filename;\r\n        $body.informationUrl = $informa" +
            "tionUrl;\r\n        $body.installCommandLine = \"$installCommandLine\"\r\n        $bod" +
            "y.installExperience = @{\"runAsAccount\" = \"$installExperience\" };\r\n        $body." +
            "isFeatured = $false;\r\n        $body.minimumSupportedOperatingSystem = @{\"v10_160" +
            "7\" = $true };\r\n        $body.msiInformation = $null;\r\n        $body.notes = \"\";\r" +
            "\n        $body.owner = \"\";\r\n        $body.privacyInformationUrl = $null;\r\n      " +
            "  $body.publisher = $publisher;\r\n        $body.runAs32bit = $false;\r\n        $bo" +
            "dy.setupFilePath = $SetupFileName;\r\n        $body.uninstallCommandLine = \"$unins" +
            "tallCommandLine\"\r\n        if ($imageValue) {\r\n            $body.largeIcon = @{\"t" +
            "ype\" = \"image/png\"; \"value\" = $imageValue };\r\n        }\r\n        $body.displayVe" +
            "rsion = \"$($displayVersion)\"\r\n    }\r\n\r\n    $body;\r\n}\r\n\r\n########################" +
            "############################\r\n\r\nfunction GetAppFileBody($name, $size, $sizeEncry" +
            "pted, $manifest) {\r\n\r\n    $body = @{ \"@odata.type\" = \"#microsoft.graph.mobileApp" +
            "ContentFile\" };\r\n    $body.name = $name;\r\n    $body.size = $size;\r\n    $body.siz" +
            "eEncrypted = $sizeEncrypted;\r\n    $body.manifest = $manifest;\r\n    $body.isDepen" +
            "dency = $false;\r\n\r\n    $body;\r\n}\r\n\r\n############################################" +
            "########\r\n\r\nfunction GetAppCommitBody($contentVersionId, $LobType) {\r\n\r\n    $bod" +
            "y = @{ \"@odata.type\" = \"#$LobType\" };\r\n    $body.committedContentVersion = $cont" +
            "entVersionId;\r\n\r\n    $body;\r\n\r\n}\r\n\r\n############################################" +
            "########\r\n\r\nFunction Test-SourceFile() {\r\n\r\n    param\r\n    (\r\n        [parameter" +
            "(Mandatory = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $SourceFile\r\n " +
            "   )\r\n\r\n    try {\r\n\r\n        if (!(test-path \"$SourceFile\")) {\r\n\r\n            Wr" +
            "ite-Host\r\n            Write-Host \"Source File \'$sourceFile\' doesn\'t exist...\" -F" +
            "oregroundColor Red\r\n            throw\r\n\r\n        }\r\n\r\n    }\r\n\r\n    catch {\r\n\r\n  " +
            "      Write-Host -ForegroundColor Red $_.Exception.Message;\r\n        Write-Host\r" +
            "\n        break\r\n\r\n    }\r\n\r\n}\r\n\r\n################################################" +
            "####\r\n\r\nFunction New-DetectionRule() {\r\n\r\n    [cmdletbinding()]\r\n\r\n    param\r\n  " +
            "  (\r\n        [parameter(Mandatory = $true, ParameterSetName = \"PowerShell\", Posi" +
            "tion = 1)]\r\n        [Switch]$PowerShell,\r\n\r\n        [parameter(Mandatory = $true" +
            ", ParameterSetName = \"MSI\", Position = 1)]\r\n        [Switch]$MSI,\r\n\r\n        [pa" +
            "rameter(Mandatory = $true, ParameterSetName = \"File\", Position = 1)]\r\n        [S" +
            "witch]$File,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"Regist" +
            "ry\", Position = 1)]\r\n        [Switch]$Registry,\r\n\r\n        [parameter(Mandatory " +
            "= $true, ParameterSetName = \"PowerShell\")]\r\n        [ValidateNotNullOrEmpty()]\r\n" +
            "        [String]$ScriptFile,\r\n\r\n        [parameter(Mandatory = $true, ParameterS" +
            "etName = \"PowerShell\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $enforceSig" +
            "natureCheck,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"PowerS" +
            "hell\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $runAs32Bit,\r\n\r\n        [pa" +
            "rameter(Mandatory = $true, ParameterSetName = \"MSI\")]\r\n        [ValidateNotNullO" +
            "rEmpty()]\r\n        [String]$MSIproductCode,\r\n   \r\n        [parameter(Mandatory =" +
            " $true, ParameterSetName = \"File\")]\r\n        [ValidateNotNullOrEmpty()]\r\n       " +
            " [String]$Path,\r\n \r\n        [parameter(Mandatory = $true, ParameterSetName = \"Fi" +
            "le\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$FileOrFolderName,\r\n\r" +
            "\n        [parameter(Mandatory = $true, ParameterSetName = \"File\")]\r\n        [Val" +
            "idateSet(\"notConfigured\", \"exists\", \"modifiedDate\", \"createdDate\", \"version\", \"s" +
            "izeInMB\")]\r\n        [string]$FileDetectionType,\r\n\r\n        [parameter(Mandatory " +
            "= $false, ParameterSetName = \"File\")]\r\n        $FileDetectionValue = $null,\r\n\r\n " +
            "       [parameter(Mandatory = $true, ParameterSetName = \"File\")]\r\n        [Valid" +
            "ateSet(\"True\", \"False\")]\r\n        [string]$check32BitOn64System = \"False\",\r\n\r\n  " +
            "      [parameter(Mandatory = $true, ParameterSetName = \"Registry\")]\r\n        [Va" +
            "lidateNotNullOrEmpty()]\r\n        [String]$RegistryKeyPath,\r\n\r\n        [parameter" +
            "(Mandatory = $true, ParameterSetName = \"Registry\")]\r\n        [ValidateSet(\"notCo" +
            "nfigured\", \"exists\", \"doesNotExist\", \"string\", \"integer\", \"version\")]\r\n        [" +
            "string]$RegistryDetectionType,\r\n\r\n        [parameter(Mandatory = $false, Paramet" +
            "erSetName = \"Registry\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]$R" +
            "egistryValue,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"Regis" +
            "try\")]\r\n        [ValidateSet(\"True\", \"False\")]\r\n        [string]$check32BitRegOn" +
            "64System = \"False\"\r\n\r\n    )\r\n\r\n    if ($PowerShell) {\r\n\r\n        if (!(Test-Path" +
            " \"$ScriptFile\")) {\r\n            \r\n            Write-Host\r\n            Write-Host" +
            " \"Could not find file \'$ScriptFile\'...\" -ForegroundColor Red\r\n            Write-" +
            "Host \"Script can\'t continue...\" -ForegroundColor Red\r\n            Write-Host\r\n  " +
            "          break\r\n\r\n        }\r\n        \r\n        $bReq = [System.Text.Encoding]::" +
            "UTF8.GetBytes((Get-Content -Path $ScriptFile))\r\n        $ScriptContent = [System" +
            ".Convert]::ToBase64String($bReq)\r\n        \r\n        $DR = @{ \"@odata.type\" = \"#m" +
            "icrosoft.graph.win32LobAppPowerShellScriptDetection\" }\r\n        $DR.enforceSigna" +
            "tureCheck = $false;\r\n        $DR.runAs32Bit = $false;\r\n        $DR.scriptContent" +
            " = \"$ScriptContent\";\r\n\r\n    }\r\n    \r\n    elseif ($MSI) {\r\n    \r\n        $DR = @{" +
            " \"@odata.type\" = \"#microsoft.graph.win32LobAppProductCodeDetection\" }\r\n        $" +
            "DR.productVersionOperator = \"notConfigured\";\r\n        $DR.productCode = \"$MsiPro" +
            "ductCode\";\r\n        $DR.productVersion = $null;\r\n\r\n    }\r\n\r\n    elseif ($File) {" +
            "\r\n    \r\n        $DR = @{ \"@odata.type\" = \"#microsoft.graph.win32LobAppFileSystem" +
            "Detection\" }\r\n        $DR.check32BitOn64System = \"$check32BitOn64System\";\r\n     " +
            "   $DR.detectionType = \"$FileDetectionType\";\r\n        $DR.detectionValue = $File" +
            "DetectionValue;\r\n        $DR.fileOrFolderName = \"$FileOrFolderName\";\r\n        $D" +
            "R.operator = \"notConfigured\";\r\n        $DR.path = \"$Path\"\r\n\r\n    }\r\n\r\n    elseif" +
            " ($Registry) {\r\n    \r\n        $DR = @{ \"@odata.type\" = \"#microsoft.graph.win32Lo" +
            "bAppRegistryDetection\" }\r\n        $DR.check32BitOn64System = \"$check32BitRegOn64" +
            "System\";\r\n        $DR.detectionType = \"$RegistryDetectionType\";\r\n        $DR.det" +
            "ectionValue = \"\";\r\n        $DR.keyPath = \"$RegistryKeyPath\";\r\n        $DR.operat" +
            "or = \"notConfigured\";\r\n        $DR.valueName = \"$RegistryValue\"\r\n\r\n    }\r\n\r\n    " +
            "return $DR\r\n\r\n}\r\n\r\n####################################################\r\n\r\nfunct" +
            "ion Get-DefaultReturnCodes() {\r\n\r\n    @{\"returnCode\" = 0; \"type\" = \"success\" }, " +
            "`\r\n    @{\"returnCode\" = 1707; \"type\" = \"success\" }, `\r\n    @{\"returnCode\" = 3010" +
            "; \"type\" = \"softReboot\" }, `\r\n    @{\"returnCode\" = 1641; \"type\" = \"hardReboot\" }" +
            ", `\r\n    @{\"returnCode\" = 1618; \"type\" = \"retry\" }\r\n\r\n}\r\n\r\n#####################" +
            "###############################\r\n\r\nfunction New-ReturnCode() {\r\n\r\n    param\r\n   " +
            " (\r\n        [parameter(Mandatory = $true)]\r\n        [int]$returnCode,\r\n        [" +
            "parameter(Mandatory = $true)]\r\n        [ValidateSet(\'success\', \'softReboot\', \'ha" +
            "rdReboot\', \'retry\')]\r\n        $type\r\n    )\r\n\r\n    @{\"returnCode\" = $returnCode; " +
            "\"type\" = \"$type\" }\r\n\r\n}\r\n\r\n####################################################\r" +
            "\n\r\nFunction Get-IntuneWinXML() {\r\n\r\n    param\r\n    (\r\n        [Parameter(Mandato" +
            "ry = $true)]\r\n        $SourceFile,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n  " +
            "      $fileName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [ValidateSe" +
            "t(\"false\", \"true\")]\r\n        [string]$removeitem = \"true\"\r\n    )\r\n\r\n    Test-Sou" +
            "rceFile \"$SourceFile\"\r\n\r\n    $Directory = [System.IO.Path]::GetDirectoryName(\"$S" +
            "ourceFile\")\r\n\r\n    Add-Type -Assembly System.IO.Compression.FileSystem\r\n    $zip" +
            " = [IO.Compression.ZipFile]::OpenRead(\"$SourceFile\")\r\n\r\n    $zip.Entries | where" +
            " { $_.Name -like \"$filename\" } | foreach {\r\n\r\n        [System.IO.Compression.Zip" +
            "FileExtensions]::ExtractToFile($_, \"$Directory\\$filename\", $true)\r\n\r\n    }\r\n\r\n  " +
            "  $zip.Dispose()\r\n\r\n    [xml]$IntuneWinXML = gc \"$Directory\\$filename\"\r\n\r\n    re" +
            "turn $IntuneWinXML\r\n\r\n    if ($removeitem -eq \"true\") { remove-item \"$Directory\\" +
            "$filename\" }\r\n\r\n}\r\n\r\n####################################################\r\n\r\nFun" +
            "ction Get-IntuneWinFile() {\r\n\r\n    param\r\n    (\r\n        [Parameter(Mandatory = " +
            "$true)]\r\n        $SourceFile,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n       " +
            " $fileName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$Folder " +
            "= \"win32\"\r\n    )\r\n\r\n    $Directory = [System.IO.Path]::GetDirectoryName(\"$Source" +
            "File\")\r\n\r\n    if (!(Test-Path \"$Directory\\$folder\")) {\r\n\r\n        New-Item -Item" +
            "Type Directory -Path \"$Directory\" -Name \"$folder\" | Out-Null\r\n\r\n    }\r\n\r\n    Add" +
            "-Type -Assembly System.IO.Compression.FileSystem\r\n    $zip = [IO.Compression.Zip" +
            "File]::OpenRead(\"$SourceFile\")\r\n\r\n    $zip.Entries | where { $_.Name -like \"$fil" +
            "ename\" } | foreach {\r\n\r\n        [System.IO.Compression.ZipFileExtensions]::Extra" +
            "ctToFile($_, \"$Directory\\$folder\\$filename\", $true)\r\n\r\n    }\r\n\r\n    $zip.Dispose" +
            "()\r\n\r\n    return \"$Directory\\$folder\\$filename\"\r\n\r\n    if ($removeitem -eq \"true" +
            "\") { remove-item \"$Directory\\$filename\" }\r\n\r\n}\r\n\r\n##############################" +
            "######################\r\n\r\nfunction Upload-Win32Lob() {\r\n\r\n    <#\r\n.SYNOPSIS\r\nThi" +
            "s function is used to upload a Win32 Application to the Intune Service\r\n.DESCRIP" +
            "TION\r\nThis function is used to upload a Win32 Application to the Intune Service\r" +
            "\n.EXAMPLE\r\nUpload-Win32Lob \"C:\\Packages\\package.intunewin\" -publisher \"Microsoft" +
            "\" -description \"Package\"\r\nThis example uses all parameters required to add an in" +
            "tunewin File into the Intune Service\r\n.NOTES\r\nNAME: Upload-Win32LOB\r\n#>\r\n\r\n    [" +
            "cmdletbinding()]\r\n\r\n    param\r\n    (\r\n        [parameter(Mandatory = $true, Posi" +
            "tion = 1)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$SourceFile,\r\n\r\n" +
            "        [parameter(Mandatory = $false)]\r\n        [ValidateNotNullOrEmpty()]\r\n   " +
            "     [string]$displayName,\r\n\r\n        [parameter(Mandatory = $true, Position = 2" +
            ")]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$publisher,\r\n\r\n        [" +
            "parameter(Mandatory = $true, Position = 3)]\r\n        [ValidateNotNullOrEmpty()]\r" +
            "\n        [string]$description,\r\n\r\n        [parameter(Mandatory = $true, Position" +
            " = 4)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $detectionRules,\r\n\r\n        " +
            "[parameter(Mandatory = $true, Position = 5)]\r\n        [ValidateNotNullOrEmpty()]" +
            "\r\n        $returnCodes,\r\n\r\n        [parameter(Mandatory = $false, Position = 6)]" +
            "\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$installCmdLine,\r\n\r\n      " +
            "  [parameter(Mandatory = $false, Position = 7)]\r\n        [ValidateNotNullOrEmpty" +
            "()]\r\n        [string]$uninstallCmdLine,\r\n\r\n        [parameter(Mandatory = $false" +
            ", Position = 8)]\r\n        [ValidateSet(\'system\', \'user\')]\r\n        $installExper" +
            "ience = \"system\",\r\n\r\n        [parameter(Mandatory = $false, Position = 9)]\r\n    " +
            "    [ValidateNotNullOrEmpty()]\r\n        $imageValue,\r\n\r\n        [parameter(Manda" +
            "tory = $false, Position = 10)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $inf" +
            "ormationURL,\r\n\r\n        [parameter(Mandatory = $false, Position = 11)]\r\n        " +
            "[ValidateNotNullOrEmpty()]\r\n        $developer,\r\n\r\n        [parameter(Mandatory " +
            "= $true, Position = 12)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $requireme" +
            "ntRules,\r\n\r\n        [parameter(Mandatory = $true, Position = 13)]\r\n        [Vali" +
            "dateNotNullOrEmpty()]\r\n        $notes,\r\n\r\n        [parameter(Mandatory = $false," +
            " Position = 14)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $displayVersion = " +
            "\"\"\r\n    )\r\n\r\n    try\t{\r\n\r\n        $LOBType = \"microsoft.graph.win32LobApp\"\r\n\r\n  " +
            "      Write-Host \"Testing if SourceFile \'$SourceFile\' Path is valid...\" -Foregro" +
            "undColor Yellow\r\n        Test-SourceFile \"$SourceFile\"\r\n\r\n        $Win32Path = \"" +
            "$SourceFile\"\r\n\r\n        Write-Host\r\n        Write-Host \"Creating JSON data to pa" +
            "ss to the service...\" -ForegroundColor Yellow\r\n\r\n        # Funciton to read Win3" +
            "2LOB file\r\n        $DetectionXML = Get-IntuneWinXML \"$SourceFile\" -fileName \"det" +
            "ection.xml\"\r\n\r\n        # If displayName input don\'t use Name from detection.xml " +
            "file\r\n        if ($displayName) { $DisplayName = $displayName }\r\n        else { " +
            "$DisplayName = $DetectionXML.ApplicationInfo.Name }\r\n        \r\n        $FileName" +
            " = $DetectionXML.ApplicationInfo.FileName\r\n\r\n        $SetupFileName = $Detection" +
            "XML.ApplicationInfo.SetupFile\r\n\r\n        $Ext = [System.IO.Path]::GetExtension($" +
            "SetupFileName)\r\n\r\n        if ((($Ext).contains(\"msi\") -or ($Ext).contains(\"Msi\")" +
            ") -and (!$installCmdLine -or !$uninstallCmdLine)) {\r\n\r\n            # MSI\r\n      " +
            "      $MsiExecutionContext = $DetectionXML.ApplicationInfo.MsiInfo.MsiExecutionC" +
            "ontext\r\n            $MsiPackageType = \"DualPurpose\";\r\n            if ($MsiExecut" +
            "ionContext -eq \"System\") { $MsiPackageType = \"PerMachine\" }\r\n            elseif " +
            "($MsiExecutionContext -eq \"User\") { $MsiPackageType = \"PerUser\" }\r\n\r\n           " +
            " $MsiProductCode = $DetectionXML.ApplicationInfo.MsiInfo.MsiProductCode\r\n       " +
            "     $MsiProductVersion = $DetectionXML.ApplicationInfo.MsiInfo.MsiProductVersio" +
            "n\r\n            $MsiPublisher = $DetectionXML.ApplicationInfo.MsiInfo.MsiPublishe" +
            "r\r\n            $MsiRequiresReboot = $DetectionXML.ApplicationInfo.MsiInfo.MsiReq" +
            "uiresReboot\r\n            $MsiUpgradeCode = $DetectionXML.ApplicationInfo.MsiInfo" +
            ".MsiUpgradeCode\r\n            \r\n            if ($MsiRequiresReboot -eq \"false\") {" +
            " $MsiRequiresReboot = $false }\r\n            elseif ($MsiRequiresReboot -eq \"true" +
            "\") { $MsiRequiresReboot = $true }\r\n\r\n            $mobileAppBody = GetWin32AppBod" +
            "y `\r\n                -MSI `\r\n                -displayName \"$DisplayName\" `\r\n    " +
            "            -publisher \"$publisher\" `\r\n                -description $description" +
            " `\r\n                -filename $FileName `\r\n                -SetupFileName \"$Setu" +
            "pFileName\" `\r\n                -installExperience $installExperience `\r\n         " +
            "       -MsiPackageType $MsiPackageType `\r\n                -MsiProductCode $MsiPr" +
            "oductCode `\r\n                -MsiProductName $displayName `\r\n                -Ms" +
            "iProductVersion $MsiProductVersion `\r\n                -MsiPublisher $MsiPublishe" +
            "r `\r\n                -MsiRequiresReboot $MsiRequiresReboot `\r\n                -M" +
            "siUpgradeCode $MsiUpgradeCode `\r\n                -displayVersion $displayVersion" +
            "\r\n        }\r\n\r\n        else {\r\n\r\n            $mobileAppBody = GetWin32AppBody -E" +
            "XE -displayName \"$DisplayName\" -publisher \"$publisher\" `\r\n                -descr" +
            "iption $description -filename $FileName -SetupFileName \"$SetupFileName\" `\r\n     " +
            "           -installExperience $installExperience -installCommandLine $installCmd" +
            "Line `\r\n                -uninstallCommandLine $uninstallcmdline -imageValue $ima" +
            "geValue `\r\n                -informationURL $informationURL -developer $developer" +
            " `\r\n                -displayVersion $displayVersion\r\n            if ($notes) { $" +
            "mobileAppBody.notes = $notes }\r\n        }\r\n\r\n        if ($DetectionRules.\'@odata" +
            ".type\' -contains \"#microsoft.graph.win32LobAppPowerShellScriptDetection\" -and @(" +
            "$DetectionRules).\'@odata.type\'.Count -gt 1) {\r\n            Write-Host\r\n         " +
            "   Write-Warning \"A Detection Rule can either be \'Manually configure detection r" +
            "ules\' or \'Use a custom detection script\'\"\r\n            Write-Warning \"It can\'t i" +
            "nclude both...\"\r\n            Write-Host\r\n            break\r\n        }\r\n        e" +
            "lse {\r\n            $mobileAppBody | Add-Member -MemberType NoteProperty -Name \'d" +
            "etectionRules\' -Value $detectionRules\r\n        }\r\n\r\n        if ($requirementRule" +
            "s.\'@odata.type\' -contains \"#microsoft.graph.win32LobAppPowerShellScriptRequireme" +
            "nt\" -and @($requirementRules).\'@odata.type\'.Count -gt 1) {\r\n            Write-Ho" +
            "st\r\n            Write-Warning \"A Detection Rule can either be \'Manually configur" +
            "e requirement rules\' or \'Use a custom requirement script\'\"\r\n            Write-Wa" +
            "rning \"It can\'t include both...\"\r\n            Write-Host\r\n            break\r\n   " +
            "     }\r\n        else {\r\n            $mobileAppBody | Add-Member -MemberType Note" +
            "Property -Name \'requirementRules\' -Value $requirementRules\r\n        }\r\n\r\n       " +
            " #ReturnCodes\r\n\r\n        if ($returnCodes) {\r\n        \r\n            $mobileAppBo" +
            "dy | Add-Member -MemberType NoteProperty -Name \'returnCodes\' -Value @($returnCod" +
            "es)\r\n\r\n        }\r\n\r\n        else {\r\n\r\n            Write-Host\r\n            Write-" +
            "Warning \"Intunewin file requires ReturnCodes to be specified\"\r\n            Write" +
            "-Warning \"If you want to use the default ReturnCode run \'Get-DefaultReturnCodes\'" +
            "\"\r\n            Write-Host\r\n            break\r\n\r\n        }\r\n\r\n        Write-Host\r" +
            "\n        Write-Host \"Creating application in Intune...\" -ForegroundColor Yellow\r" +
            "\n        $mobileApp = MakePostRequest \"mobileApps\" ($mobileAppBody | ConvertTo-J" +
            "son);\r\n\r\n        # Get the content version for the new app (this will always be " +
            "1 until the new app is committed).\r\n        Write-Host\r\n        Write-Host \"Crea" +
            "ting Content Version in the service for the application...\" -ForegroundColor Yel" +
            "low\r\n        $appId = $mobileApp.id;\r\n        $contentVersionUri = \"mobileApps/$" +
            "appId/$LOBType/contentVersions\";\r\n        $contentVersion = MakePostRequest $con" +
            "tentVersionUri \"{}\";\r\n\r\n        # Encrypt file and Get File Information\r\n       " +
            " Write-Host\r\n        Write-Host \"Getting Encryption Information for \'$SourceFile" +
            "\'...\" -ForegroundColor Yellow\r\n\r\n        $encryptionInfo = @{ };\r\n        $encry" +
            "ptionInfo.encryptionKey = $DetectionXML.ApplicationInfo.EncryptionInfo.Encryptio" +
            "nKey\r\n        $encryptionInfo.macKey = $DetectionXML.ApplicationInfo.EncryptionI" +
            "nfo.macKey\r\n        $encryptionInfo.initializationVector = $DetectionXML.Applica" +
            "tionInfo.EncryptionInfo.initializationVector\r\n        $encryptionInfo.mac = $Det" +
            "ectionXML.ApplicationInfo.EncryptionInfo.mac\r\n        $encryptionInfo.profileIde" +
            "ntifier = \"ProfileVersion1\";\r\n        $encryptionInfo.fileDigest = $DetectionXML" +
            ".ApplicationInfo.EncryptionInfo.fileDigest\r\n        $encryptionInfo.fileDigestAl" +
            "gorithm = $DetectionXML.ApplicationInfo.EncryptionInfo.fileDigestAlgorithm\r\n\r\n  " +
            "      $fileEncryptionInfo = @{ };\r\n        $fileEncryptionInfo.fileEncryptionInf" +
            "o = $encryptionInfo;\r\n\r\n        # Extracting encrypted file\r\n        $IntuneWinF" +
            "ile = Get-IntuneWinFile \"$SourceFile\" -fileName \"$filename\"\r\n\r\n        [int64]$S" +
            "ize = $DetectionXML.ApplicationInfo.UnencryptedContentSize\r\n        $EncrySize =" +
            " (Get-Item \"$IntuneWinFile\").Length\r\n\r\n        # Create a new file for the app.\r" +
            "\n        Write-Host\r\n        Write-Host \"Creating a new file entry in Azure for " +
            "the upload...\" -ForegroundColor Yellow\r\n        $contentVersionId = $contentVers" +
            "ion.id;\r\n        $fileBody = GetAppFileBody \"$FileName\" $Size $EncrySize $null;\r" +
            "\n        $filesUri = \"mobileApps/$appId/$LOBType/contentVersions/$contentVersion" +
            "Id/files\";\r\n        $file = MakePostRequest $filesUri ($fileBody | ConvertTo-Jso" +
            "n);\r\n\t\r\n        # Wait for the service to process the new file request.\r\n       " +
            " Write-Host\r\n        Write-Host \"Waiting for the file entry URI to be created..." +
            "\" -ForegroundColor Yellow\r\n        $fileId = $file.id;\r\n        $fileUri = \"mobi" +
            "leApps/$appId/$LOBType/contentVersions/$contentVersionId/files/$fileId\";\r\n      " +
            "  $file = WaitForFileProcessing $fileUri \"AzureStorageUriRequest\";\r\n\r\n        # " +
            "Upload the content to Azure Storage.\r\n        Write-Host\r\n        Write-Host \"Up" +
            "loading file to Azure Storage...\" -f Yellow\r\n\r\n        $sasUri = $file.azureStor" +
            "ageUri;\r\n        UploadFileToAzureStorage $file.azureStorageUri \"$IntuneWinFile\"" +
            " $fileUri;\r\n\r\n        # Need to Add removal of IntuneWin file\r\n        $IntuneWi" +
            "nFolder = [System.IO.Path]::GetDirectoryName(\"$IntuneWinFile\")\r\n        Remove-I" +
            "tem \"$IntuneWinFile\" -Force\r\n\r\n        # Commit the file.\r\n        Write-Host\r\n " +
            "       Write-Host \"Committing the file into Azure Storage...\" -ForegroundColor Y" +
            "ellow\r\n        $commitFileUri = \"mobileApps/$appId/$LOBType/contentVersions/$con" +
            "tentVersionId/files/$fileId/commit\";\r\n        MakePostRequest $commitFileUri ($f" +
            "ileEncryptionInfo | ConvertTo-Json);\r\n\r\n        # Wait for the service to proces" +
            "s the commit file request.\r\n        Write-Host\r\n        Write-Host \"Waiting for " +
            "the service to process the commit file request...\" -ForegroundColor Yellow\r\n    " +
            "    $file = WaitForFileProcessing $fileUri \"CommitFile\";\r\n\r\n        # Commit the" +
            " app.\r\n        Write-Host\r\n        Write-Host \"Committing the file into Azure St" +
            "orage...\" -ForegroundColor Yellow\r\n        $commitAppUri = \"mobileApps/$appId\";\r" +
            "\n        $commitAppBody = GetAppCommitBody $contentVersionId $LOBType;\r\n        " +
            "MakePatchRequest $commitAppUri ($commitAppBody | ConvertTo-Json);\r\n\r\n        Wri" +
            "te-Host \"Sleeping for $sleep seconds to allow patch completion...\" -f Magenta\r\n " +
            "       Start-Sleep $sleep\r\n        Write-Host\r\n    \r\n    }\r\n\t\r\n    catch {\r\n\r\n  " +
            "      Write-Host \"\";\r\n        Write-Host -ForegroundColor Red \"Aborting with exc" +
            "eption: $($_.Exception.ToString())\";\r\n\t\r\n    }\r\n}\r\n\r\n###########################" +
            "#########################\r\n\r\nFunction Test-AuthToken() {\r\n\r\n    # Checking if au" +
            "thToken exists before running authentication\r\n    if ($global:authToken) {\r\n\r\n  " +
            "      # Setting DateTime to Universal time to work in all timezones\r\n        $Da" +
            "teTime = (Get-Date).ToUniversalTime()\r\n\r\n        # If the authToken exists check" +
            "ing when it expires\r\n        $TokenExpires = ($authToken.ExpiresOn.datetime - $D" +
            "ateTime).Minutes\r\n\r\n        if ($TokenExpires -le 0) {\r\n\r\n            write-host" +
            " \"Authentication Token expired\" $TokenExpires \"minutes ago\" -ForegroundColor Yel" +
            "low\r\n            write-host\r\n\r\n            # Defining Azure AD tenant name, this" +
            " is the name of your Azure Active Directory (do not use the verified domain name" +
            ")\r\n\r\n            if ($User -eq $null -or $User -eq \"\") {\r\n\r\n                $Glo" +
            "bal:User = Read-Host -Prompt \"Please specify your user principal name for Azure " +
            "Authentication\"\r\n                Write-Host\r\n\r\n            }\r\n\r\n            $glo" +
            "bal:authToken = Get-AuthToken -User $User\r\n\r\n        }\r\n    }\r\n\r\n    # Authentic" +
            "ation doesn\'t exist, calling Get-AuthToken function\r\n\r\n    else {\r\n\r\n        if " +
            "($User -eq $null -or $User -eq \"\") {\r\n\r\n            $Global:User = Read-Host -Pr" +
            "ompt \"Please specify your user principal name for Azure Authentication\"\r\n       " +
            "     Write-Host\r\n\r\n        }\r\n\r\n        # Getting the authorization token\r\n     " +
            "   $global:authToken = Get-AuthToken -User $User\r\n\r\n    }\r\n}\r\n\r\n################" +
            "####################################\r\n\r\n\r\n######################################" +
            "##############\r\n\r\n$baseUrl = \"https://graph.microsoft.com/beta/deviceAppManageme" +
            "nt/\"\r\n\r\n$logRequestUris = $true;\r\n$logHeaders = $false;\r\n$logContent = $true;\r\n\r" +
            "\n$azureStorageUploadChunkSizeInMb = 6l;\r\n\r\n$sleep = 30\r\n\r\n######################" +
            "##############################\r\n# Sample Win32 Application\r\n####################" +
            "################################\r\n# args0 = ShortName string\r\n# args1 = Token st" +
            "ring\r\n# args2 = ExpireTime string\r\n# args3 = Username\r\n\r\nAdd-Type -AssemblyName " +
            "System.Web\r\n#Check if nuget provider is installed...\r\nif (-NOT (Get-PackageProvi" +
            "der nuget -ListAvailable -ea SilentlyContinue)) { Install-PackageProvider -Name " +
            "\"Nuget\" -Force }\r\n\r\n#Install AzureAD Module if missing\r\ntry {\r\n    if ([version]" +
            "(((Get-Module -ListAvailable AzureAD) | Sort-Object version)[-1]).Version -lt \"2" +
            ".0.2.61\") { Install-Module AzureAD -Force -Confirm:$false }\r\n}\r\ncatch { Install-" +
            "Module AzureAD -Force -Confirm:$false }\r\n\r\n$ShortName = $args[0]\r\n$global:authTo" +
            "ken = @{ \"Content-Type\" = \"application/json\"; \"Authorization\" = \"Bearer $($args[" +
            "1])\" ; \"ExpiresOn\" = [DateTimeOffset]::Parse($args[2]) }\r\n$Global:User = $args[3" +
            "]\r\n#$global:authToken = Get-AuthToken -User $User\r\n$outFolder = \"$env:temp\\intun" +
            "ewin\"\r\nif (-NOT (Test-Path $outFolder)) { New-Item -Path $outFolder -ItemType Di" +
            "rectory }\r\n#Remove-Item $sourceFolder -Recurse -Force -ea SilentlyContinue\r\n#New" +
            "-Item $sourceFolder -ItemType Directory -Force\r\n\r\n$url = Invoke-RestMethod -Uri " +
            "\"https://ruckzuck.tools/rest/v2/geturl\"\r\n$rzSW = Invoke-RestMethod -Uri \"$($url)" +
            "/rest/v2/getsoftwares?shortname=$([System.Web.HttpUtility]::UrlEncode($ShortName" +
            "))\" \r\n\r\n#rzSW can have multiple InstallTypes\r\nif ($rzSW.count -gt 1) {\r\n    #tak" +
            "e InstallType that matches the PreRequisites\r\n    $rzsw = $rzsw | ForEach-Object" +
            " { if ($_.PSPreReq | Invoke-Expression) { $_ } }\r\n}\r\n\r\n$sourceFolder = \"$env:tem" +
            "p\\$($rzSW.ContentID)\"\r\n$file = $rzSW.ShortName\r\n$rzSW.Files | ForEach-Object { \r" +
            "\n    #Invoke-WebRequest -Uri $_.URL -OutFile \"$($sourceFolder)\\$($_.FileName)\"\r\n" +
            "    $file = $_.FileName\r\n}\r\nif (-NOT (Test-Path $sourceFolder)) { New-Item -Path" +
            " $sourceFolder -ItemType Directory }\r\nInvoke-WebRequest -Uri $rzSW.iconURL -OutF" +
            "ile \"$($sourceFolder)\\logo.png\"\r\n\r\n#Download IntuneWinAppUtil\r\nif (-NOT (Test-Pa" +
            "th \"$($env:temp)\\IntuneWinAppUtil.exe\")) {\r\n    Invoke-WebRequest -Uri \"https://" +
            "raw.githubusercontent.com/microsoft/Microsoft-Win32-Content-Prep-Tool/master/Int" +
            "uneWinAppUtil.exe\" -OutFile \"$($env:temp)\\IntuneWinAppUtil.exe\"\r\n}\r\n&\"$($env:tem" +
            "p)\\IntuneWinAppUtil.exe\" -c $sourceFolder -s $file -o $outFolder -q\r\n\r\n$file = [" +
            "io.path]::GetFileNameWithoutExtension($file)\r\n$SourceFile = \"$($outFolder)\\$($fi" +
            "le).intunewin\"\r\n\r\n$img = [Convert]::ToBase64String((Invoke-WebRequest \"$($rzSW.i" +
            "conURL)&size=128\").Content)\r\n#$img = [Convert]::ToBase64String($rzSW.Image)\r\n\r\n#" +
            " Defining Intunewin32 detectionRules\r\n#$DetectionXML = Get-IntuneWinXML \"$Source" +
            "File\" -fileName \"detection.xml\"\r\n$PowerShellScript = \"$($sourceFolder)\\detection" +
            ".ps1\"\r\n$PowerShellRule = New-DetectionRule -PowerShell -ScriptFile \"$PowerShellS" +
            "cript\" -enforceSignatureCheck $false -runAs32Bit $false\r\n#$RegistryRule = New-De" +
            "tectionRule -Registry -RegistryKeyPath \"HKEY_LOCAL_MACHINE\\SOFTWARE\\App\" -Regist" +
            "ryDetectionType exists -check32BitRegOn64System True\r\n# Creating Array for detec" +
            "tion Rule\r\n$DetectionRule = @($PowerShellRule)\r\n$ReturnCodes = Get-DefaultReturn" +
            "Codes\r\n\r\n$type = \'system\'\r\nif ($rzSW.PSDetection.contains(\'HKCU:\')) { $type = \'u" +
            "ser\' }\r\n\r\n#requirements\r\n$bReq = [System.Text.Encoding]::UTF8.GetBytes((Get-Cont" +
            "ent -Path \"$($sourceFolder)\\requirements.ps1\"))\r\n$reqScript = [System.Convert]::" +
            "ToBase64String($bReq)\r\n$reqRule = @(@{\"@odata.type\"    = \"#microsoft.graph.win32" +
            "LobAppPowerShellScriptRequirement\";\r\n        \"operator\"              = \"equal\";\r" +
            "\n        \"detectionValue\"        = \"true\";\r\n        \"displayName\"           = \"r" +
            "equirements\";\r\n        \"enforceSignatureCheck\" = $false;\r\n        \"runAs32Bit\"  " +
            "          = $false;\r\n        \"runAsAccount\"          = $type;\r\n        \"scriptCo" +
            "ntent\"         = $reqScript;\r\n        \"detectionType\"         = \"boolean\"\r\n    }" +
            ")\r\n\r\n#fix blank manufacturer    \r\nif (-NOT $rzSW.Manufacturer) { $rzSW.Manufactu" +
            "rer = $rzSW.ShortName }   \r\n\r\n# Win32 Application Upload\r\nUpload-Win32Lob -Sourc" +
            "eFile $SourceFile -displayName ($rzSW.ShortName + \" \" + $rzSW.ProductVersion) -p" +
            "ublisher $rzSW.Manufacturer `\r\n    -description $rzSW.Description -detectionRule" +
            "s $DetectionRule -returnCodes $ReturnCodes `\r\n    -installCmdLine \"powershell.ex" +
            "e -ExecutionPolicy Bypass .\\install.ps1\" `\r\n    -uninstallCmdLine \"powershell.ex" +
            "e -ExecutionPolicy Bypass .\\uninstall.ps1\" `\r\n    -installExperience $type `\r\n  " +
            "  -imageValue $img `\r\n    -requirementRules $reqRule `\r\n    -informationURL $rzS" +
            "W.ProductURL `\r\n    -developer \"RuckZuck\" `\r\n    -notes \"RZID:$($rzSW.SWId)`nSho" +
            "rtName:$($rzSW.ShortName)`nVersion:$($rzSW.ProductVersion)\" `\r\n    -displayVersi" +
            "on \"$($rzSW.ProductVersion)\"\r\n\r\n################################################" +
            "####")]
        public string RZCreateAppPS {
            get {
                return ((string)(this["RZCreateAppPS"]));
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("<?xml version=\"1.0\" encoding=\"utf-16\"?>\r\n<ArrayOfString xmlns:xsi=\"http://www.w3." +
            "org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" />")]
        public global::System.Collections.Specialized.StringCollection UpdExlusion {
            get {
                return ((global::System.Collections.Specialized.StringCollection)(this["UpdExlusion"]));
            }
            set {
                this["UpdExlusion"] = value;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool NoExit {
            get {
                return ((bool)(this["NoExit"]));
            }
        }
    }
}
